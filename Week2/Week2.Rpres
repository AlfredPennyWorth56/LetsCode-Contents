<style>
.small-code pre code {
  font-size: 1em;
}
</style>

Let's Code - Week 2
========================================================
author: Adrien ROUX
date: January, 2017
autosize: true

Debrief de la Week 1
========================================================
class: small-code

* Questions,
* Open issues,
* Missing installs,

Control Strutures (1/.)
========================================================
class: small-code

Control structures in R allow you to control the flow of execution of a series of R expressions. 

Basically, they allow you to put some **logic** into your R code, rather than just always executing the same R code every time. 

They allow you to respond to inputs or to features of the data and execute different R expressions accordingly.

Control Strutures (2/.)
========================================================
class: small-code

Commonly used control structures are:
* **if** and **else**: testing a condition and acting on it
* **for**: execute a loop a fixed number of times
* **while**: execute a loop while a condition is true
* **repeat**: execute an infinite loop (must break out of it to stop)
* **break**: break the execution of a loop
* **next**: skip an interation of a loop

Control Strutures : If and Else (1/.)
========================================================
class: small-code


Control Strutures : For (1/.)
========================================================
class: small-code



Control Strutures : While (1/.)
========================================================
class: small-code


Control Strutures : Repeat (1/.)
========================================================
class: small-code



Functions (1/.)
========================================================
class: small-code

Writing functions is a core activity of an R programmer. It represents the key step of the transition from a mere *user* to a developer who creates new functionality for R. 

Functions are often used to encapsulate a sequence of expressions that need to be executed numerous times, perhaps under slightly different conditions. Functions are also often written when code must be shared with others or the public.

The writing of a function allows a developer to create an interface to the code, that is explicitly specified with a set of parameters. This interface provides an abstraction of the code to potential users. This abstraction simplifies the users lives because it relieves them from having to know every detail of how the code operates. In addition, the creation of an interface allows the developer to communicate to the user the aspects of the code that are important or are most relevant.

Functions (2/.)
========================================================
class: small-code

STOP TALKING!

**Your First Function:**
Functions are defined using the function() directive and are stored as R objects just like anything else. In particular, they are R objects of class **function**.

Here’s a simple function that takes no arguments and does nothing.
```{r}
f <- function() {
## This is an empty function
}
```

```{r}
## Functions have their own class
class(f)

## Execute function
f()
```

Functions (3/.)
========================================================
class: small-code

Not very interesting, but it’s a start. The next thing we can do is create a function that actually has a non-trivial function body.

```{r}
f <- function() {
  cat("Hello, wOrld!\n")
}
f()
```



Getting Data In and Out of R
========================================================
class: small-code

multiple use cases:
* data are available on your computer locally or through local network,
* data are available through R repository => dataset reference,
* data is stored in outside world... API + classic web


Getting Data In and Out of R on your computer
========================================================
class: small-code

File manipulation in R:
* file.create(..., showWarnings = TRUE)
* file.exists(...)
* file.remove(...)
* file.rename(from, to)
* file.append(file1, file2)
* file.copy(from, to, overwrite = recursive, recursive = FALSE,
copy.mode = TRUE, copy.date = FALSE)

There is more:
file.info
file.access

All these methods are available in base package.

folder manipulation:
list.files()
getwd()
setwd()
dir.create()
dir.exists()

There are a few principal functions reading data into R:

* **read.table**, **read.csv**, for reading tabular data ;
* **readLines**, for reading lines of a text file
* **source**, for reading in R code files (inverse of dump)
* **dget**, for reading in R code files (inverse of dput)
* **load**, for reading in saved workspaces
* **unserialize**, for reading single R objects in binary form.

There are of course, many R packages that have been developed to read in all kinds of other datasets, and you may need to resort to one of these packages if you are working in a specific area.

File manipulation in R
========================================================
class: small-code



Using the readr Package
========================================================
class: small-code

Using Textual and Binary Formats for Storing Data
========================================================
class: small-code



Interfaces to the Outside World
========================================================
Data are read in using connection interfaces. Connections can be made to files (most common) or to other more exotic things.

- file, opens a connection to a file
- gzfile, opens a connection to a file compressed with gzip
- bzfile, opens a connection to a file compressed with bzip2
- url, opens a connection to a webpage


